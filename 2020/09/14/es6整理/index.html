
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="LIPER">
    <title>es6整理 - LIPER</title>
    <meta name="author" content="Liper">
    
        <meta name="keywords" content="javascript">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/p9.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liper","sameAs":["https://github.com/","mailto"],"image":"cover.jpg"},"articleBody":"\nECMAScript2015\n摘要1.新的标准规范ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。\n2.ECMAScript 和 js 关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。javascript 是 netscape 创 造的并交给了国际标准化组织 ECMA，之所以不叫做 JavaScript 由于商标的问题，java 是 sun 公司的商标，根据 授权协议只有 Netscape 公司可以合法使用 JavaScript 这个名字，另外就是为了体现 JavaScript 的标准的制定者 不是 ECMA 所以取名为 ECMAScript。\n3.ES6 与 ECMAScript 2015 的关系ES6 是 ECMA 的为 JavaScript 制定的第 6 个版本的标准，标准委员会最终决定，标准在每年的 6 月份正式发布一 次，作为当年的正式版本。ECMAscript 2015 是在 2015 年 6 月份发布的 ES6 的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本……\n块级作用域1.块级作用域的种类ECMAScript2015 为 js 提出的第三个作用域，凡是带{}的都是一个块级作用域。\nif 语句的{},for 循环中的{},while 中的{},或者是我们单独写的{} try{}catch(error){}这些都提供了块级作用域。\n块级作用域分析1.为什么需要块级作用域？\n内层变量会覆盖外层变量\n12345678var lagou = &quot;拉勾&quot;;function fn() &#123;  console.log(lagou); //undefined  if (false) &#123;    var lagou = &quot;hello&quot;;  &#125;&#125;fn();\n\n\n\n这是因为 fn 函数体内以及有 var 声明的变量 lagou，只是还没有赋值，默认为 undefined。\n\n用来计数的循环变量泄露为全局变量\n123for (var i = 0; i &lt; 10; i++) &#123;&#125;// 10console.log(i);\n\n\n\n2.块级作用域的成员块级作用域内的成员需要使用 let 或 const 命令定义的变量。\n12345678var lagou = &quot;拉勾&quot;;function fn() &#123;  console.log(lagou); //拉勾  if (true) &#123;    let lagou = &quot;hello&quot;;  &#125;&#125;fn();\n\nlet const1.let基本用法\nECMAScript2015 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。\nlet 主要声明块级作用域下的成员，这个成员变量的作用域范围只能在当前块级作用域下。\n\nwer\ner\n\n2.constconst 声明变量的同时必须要赋值。\nconst 声明之后，不允许去修改它的值，这里面的值说的是不允许修改它，是声明之后不允许重新指向一个新\n的内存地址，可以去修改内存地址中的属性成员。\n数组1.数组的解构ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。\n\n完全解构 将数组中的每一个值都对应上相应的变量。\n123var arr = [&quot;lagou&quot;, &quot;edu&quot;, &quot;web&quot;];let [com, ind, work] = arr;console.log(work); //web\n\n不完全解构 数组中的部分值对应上了相应的变量。\n123var arr = [&quot;lagou&quot;, &quot;edu&quot;, &quot;web&quot;];let [, , work] = arr;console.log(work); //web\n\n注意:模式没有匹配上的可以不填，但是必须要加逗号隔开。\n\n\n\n扩展运算符…\n\n展开运算符说明\n\n三个点(…)是一个展开运算符，其功能为对三个点后面的变量进行展开操作\n\n三个点(…)展开运算符:只能对具有 Iterator 接口的对象进行展开操作\n\n使用场景\n![image-20200508180111209](imgs/image-20200508180111209.png)\n\n案例一\n\n&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[&lt;span class=&quot;string&quot;&gt;&amp;quot;拉勾&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;edu&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn(...arr)&lt;span class=&quot;comment&quot;&gt;//web&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例二`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = [&lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;102&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;103&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.push(...b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;//[88, 99, 100, 101, 102, 103]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例三`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; d=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e:&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f:&lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g:&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;h:&lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;h&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;e&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;f&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例四`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; st=&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩 edu&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[...st];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)&lt;span class=&quot;comment&quot;&gt;//[&amp;quot;拉&amp;quot;, &amp;quot;钩&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;u&amp;quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`掌握了展开运算符的使用规则，我们看一下数组的特殊解构。`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [a,...b] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a)&lt;span class=&quot;comment&quot;&gt;//1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b)&lt;span class=&quot;comment&quot;&gt;//[2,3,4,5,6]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;\n12345678* 解构不成功  右边的变量的个数超过了等号左边中数组的元素  &#96;&#96;&#96;js  let [a, b, c] &#x3D; [12];  console.log(b); &#x2F;&#x2F;undefined\n\n\n\n\n\n如果解构没有成功，则变量的值是 undefined，如果是展开运算的变量则是空数组。\n12let [a, b, ...c] = [12];console.log(c); //[]\n\n\n\n2.数组的扩展\n扩展运算符…\n\n扩展运算符（spread）是三个点（...）它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\n替代 apply()的使用技巧\n我们之前在求一个数组中的最大值得时候采用得方式是 Math.max.apply(null,[12,34,56,43]) ==56\n1234var max = Math.max.apply(null, [12, 34, 56, 43]);console.log(max); //56var max2 = Math.max(...[12, 34, 56, 43]);console.log(max2); //56\n\n\n\nArray 类的扩展方法\n\nArray.from()\n\nArray.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）\n12345678var arraylike = &#123;  0: &quot;lagou&quot;,  1: &quot;edu&quot;,  2: &quot;web&quot;,  length: 3,&#125;;var arr = Array.from(arraylike);[&quot;lagou&quot;, &quot;edu&quot;, &quot;web&quot;];\n\nArray.from 还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组\n1234var arr = Array.from([1, 2, 3], function (x) &#123;  return x * x;&#125;);console.log(arr); //[1,4,9]\n\n\nArray.of 方法用于将一组值，转换为数组，这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。\n1var arr = Array(3); //[emptyx3]\n\n这里面 3 表示数组中元素的长度。\n1var arr = Array(2, 3, 4); //[2,3,4]\n\n当Array()里的参数个数大于 1 的时候，表示的是数组元素。\nArray.of()方法不管里面参数的个数多少，都将其转为数组的元素。\n12var arr = Array.of(3);console.log(arr); //[3]\n\n\n\n\n\n对象1.对象中有关变量的解构赋值解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n12let &#123; name, work &#125; = &#123; name: &quot;lagou&quot;, work: &quot;web&quot; &#125;;console.log(name, work); //lagou web\n\n2.对象的扩展\n对象的简写\n\n当变量名和属性名同名式，省略同名的属性值\n1234const foo = &quot;bar&quot;;const baz = &#123; foo &#125;;// 等同于const baz = &#123; foo: foo &#125;;\n\n\n\n省略方法中的 function\n1234567891011const obj = &#123;  method() &#123;    return &quot;拉勾!&quot;;  &#125;,&#125;;// 等同于const obj = &#123;  method: function () &#123;    return &quot;拉勾!&quot;;  &#125;,&#125;;\n\n\n属性的赋值器（setter）和取值器（getter）\n123456789101112const lagou = &#123;  name: &quot;拉勾&quot;,  get com() &#123;    return this.name;  &#125;,  set work(value) &#123;    this.name = this.name + value;  &#125;,&#125;;console.log(lagou.com); //拉勾lagou.work = &quot;招聘&quot;;console.log(lagou.name); //拉勾招聘\n\n属性名表达式\nes5 中定义对象的属性有两种方法，一种是用标识符做属性，一种是用表达式做属性\n12345678方法一;obj.name = &quot;拉勾&quot;;// 方法二obj[&quot;name&quot;] = &quot;拉勾&quot;;var lagou = &#123;  name: &quot;拉勾&quot;,&#125;;\n\n如果使用大括号定义对象，那么在 es5 中只能使用标识符定义属性。\n123var lagou = &#123;  name: &quot;拉勾&quot;,&#125;;\n\n但是 ECMAScript2015 在使用大括号定义对象的时候，允许使用表达式定义属性，把表达式放在方括号中。\n12345let name = &quot;lagou&quot;;const lagou = &#123;  [name]: &quot;web&quot;,&#125;;console.log(lagou); //&#123;lagou: &quot;web&quot;&#125;\n\n\n\n\n\n3.三点运算在对象中的用途\n用于对象的解构\n\n对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n12let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(z); //&#123;a: 3, b: 4&#125;\n\n上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。\n注意:1.解构赋值必须是最后一个参数。2.解构赋值的拷贝是浅拷贝。\n\n\n\n用于扩展运算\n\n对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n123let z = &#123; name: &quot;lagou&quot;, work: &quot;web&quot; &#125;;let n = &#123; ...z &#125;;n; // &#123; name: &quot;lagou&quot;, work: &quot;web&quot; &#125;\n\n\n\n\n\n字符串1.字符串模板\n传统的字符串里不能使用换行符，必须使用转义符\\n 替代，字符串模板里可以使用。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n模板字符串中嵌入变量，需要将变量名写在$&#123;&#125;之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性\n123var name = &quot;拉勾&quot;;var st = `欢迎来到$&#123;name&#125;`;console.log(st);\n\n\n\n2.标签模板\n模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。\n123console.log`hello`;等同于;console.log([&quot;hello&quot;]);\n\n标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\n注意:如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\n12345678910111213var name=&quot;laogou&quot;;var work=&quot;web&quot;function tag(st,a,b)&#123;    console.log(st);    console.log(a);    console.log(b)    return &quot;hello lagou&quot;;&#125;var st=tag`hello$&#123;name&#125;,职业$&#123;work&#125;开发`console.log(st)//hello lagou[&quot;hello&quot;, &quot;,职业&quot;, &quot;开发&quot;, raw: Array(3)]laogouweb\n\n函数内的返回值，就是tag函数处理模板字符串后的返回值。\n12345678910var name = &quot;laogou&quot;;var work = &quot;web&quot;;function tag(st, a, b) &#123;  console.log(st);  console.log(a);  console.log(b);  return &quot;hello lagou&quot;; //如果没有返回值，则默认是undefined&#125;var st = tag`hello$&#123;name&#125;,职业$&#123;work&#125;开发`;console.log(st); //hello lagou\n\n\n\n3.扩展的方法\n字符串实例的方法\n\nincludes()\n返回布尔值，表示是否找到了参数字符串\n123var st = &quot;lagou web&quot;;var b = st.includes(&quot;web&quot;);console.log(b); //true\n\nstartsWith()\n返回布尔值，表示参数字符串是否在原字符串的头部\n123var st = &quot;lagou web&quot;;var b = st.startsWith(&quot;la&quot;);console.log(b); //true\n\nendsWith()\n返回布尔值，表示参数字符串是否在原字符串的尾部\n123var st = &quot;lagou web&quot;;var b = st.endsWith(&quot;web&quot;);console.log(b); //true\n\n\n\n\n\n函数参数默认值\nES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n1234function fn(a, b = &quot; lagou &quot;) &#123;  console.log(a + b);&#125;fn(&quot;hello&quot;); //hello lagou\n\n注意:\n\n参数变量是默认声明的，所以不能用let或const再次声明.\n使用参数默认值时，函数不能有同名参数\n\n\n参数默认值的位置\n\n通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n1234567function f(x = 1, y) &#123;  return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错\n\n\n\n\n\nrest 参数\nES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n1234function add(...values) &#123;  console.log(values);&#125;add(2, 5, 3); // [2, 5, 3]\n\nrest 参数和函数中的参数解构有什么区别\n\nrest 参数是发生在函数的定义阶段，函数的额参数解构是发生在函数的调用阶段\n二者是一种互为逆运算\n\n\n\n12345678910function add(...values) &#123;  //这是rest参数  console.log(values);&#125;add(2, 5, 3); // [2, 5, 3]var arr = [1, 2, 3];function fn(a, b, c) &#123;  console.log(a + b + c);&#125;fn(...arr); //6  这是参数的解构\n\n箭头函数\nES6 允许使用“箭头”（=&gt;）定义函数。\n\n12345var f = (v) =&gt; v;// 等同于var f = function (v) &#123;  return v;&#125;;\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n1234567891011var f = () =&gt; 5;// 等同于var f = function () &#123;  return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function (num1, num2) &#123;  return num1 + num2;&#125;;\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。\n123var sum = (num1, num2) =&gt; &#123;  return num1 + num2;&#125;;\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n123let getItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;; //报错let getItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);//不报错\n\n\n箭头函数有几个使用注意点\n函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数外面的 this 是什么，箭头函数内的 this 还是什么。\n不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n\n\n123456789101112131415161718192021var name=&quot;web&quot;var obj=&#123;    name:&quot;lagou&quot;,    fn()&#123;        var t=setTimeout(function()&#123;            console.log(this.name)//web  this是window        &#125;,1000)    &#125;&#125;obj.fn()-----------------------------------var name=&quot;web&quot;var obj=&#123;    name:&quot;lagou&quot;,    fn()&#123;        var t=setTimeout(()=&gt;&#123;            console.log(this.name)//lagou this是obj        &#125;,1000)    &#125;&#125;obj.fn()\n\nObjectObject.assign()\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n1234567891011const target = &#123;  a: 123,  b: 123,&#125;;const sourcel = &#123;  a: 456,  c: 456,&#125;;const result = Object.assign(target, sourcel);console.log(target); //&#123;a: 456, b: 123, c: 456&#125;console.log(target === result); //true\n\n如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性。且assign()的返回值就是第一个对象。\n如果有多个源对象有同名属性，依然是后面的会覆盖前面的属性\n12345const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target; // &#123;a:1, b:2, c:3&#125;\n\n利用Object.assign()复制一个对象，且其中一个对象的修改不会影响到另一个对象\n1234567const sourcel = &#123;  a: 123,&#125;;var obj = Object.assign(&#123;&#125;, sourcel);obj.a = 456;console.log(obj); //&#123;a: 456&#125;console.log(sourcel); //&#123;a: 123&#125;\n\n\n\nObject.is()\nObject.is就是用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\nES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\n1234console.log(Object.is(+0, -0)); //falseconsole.log(+0 === -0); //trueconsole.log(Object.is(NaN, NaN)); //trueconsole.log(NaN === NaN); //false\n\n\n\nProxy概述Proxy 可以理解成一个快递员，我们发快递还是接受快递，都需要这个快递员充当一个代理的作用。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，这个实例就是一个代理对象（快递员）。\n1var proxy = new Proxy(target, handler);\n\n目标对象这个代理对象有两个参数，一个是代理的目标对象，第二个也是一个对象，它是配置对象，用来定制代理的拦截行为。\n1234567891011const person = &#123;  name: &quot;zce&quot;,  age: 20,&#125;;const personProxy = new Proxy(person, &#123;  get(target, property) &#123;    console.log(target, property); //person&#123;name:&quot;zce&quot;,age:20&#125;    return 100;  &#125;,  set() &#123;&#125;,&#125;);\n\n配置对象\n配置对象中一般有两个方法get和set,get是用来拦截对目标对象属性的访问请求。get方法中有两个参数，第一个参数是目标对象，第二个参数是访问的那个属性。\n12345678910111213const person = &#123;  name: &quot;zce&quot;,  age: 20,&#125;;const personProxy = new Proxy(person, &#123;  get(target, property) &#123;    console.log(target, property);    return 100;  &#125;,  set() &#123;&#125;,&#125;);console.log(personProxy.name); //100\n\n\n\n注意，这个get方法的返回值就是我们获取的这个属性的返回值。\n\n这个get方法中有三个参数，一个是代理的目标对象，一个是代理的处理对象，第三个参数是 proxy 实例本身，且第三个参数是可选参数。\n12345678910111213const person = &#123;  name: &quot;zce&quot;,  age: 20,&#125;;const personProxy = new Proxy(person, &#123;  get(target, property, o) &#123;    console.log(o); //proxy&#123;name:&quot;zec&quot;,age:20&#125;    return property in target ? target[property] : undefined;  &#125;,  set() &#123;&#125;,&#125;);console.log(personProxy.age); //20\n\n这个set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选\n123456789101112131415const person = &#123;  name: &quot;zce&quot;,  age: 20,&#125;;const personProxy = new Proxy(person, &#123;  get(target, property, o) &#123;    return property in target ? target[property] : undefined;  &#125;,  set(obj, pro, value, o) &#123;    console.log(obj, pro, value, o);  &#125;,&#125;);console.log((personProxy.name = &quot;zhang&quot;));//&#123;name: &quot;zce&quot;, age: 20&#125; &quot;name&quot; &quot;zhang&quot; Proxy &#123;name: &quot;zce&quot;, age: 20&#125;\n\n可以去设置一些属性或修改\n123456789101112131415const person = &#123;  name: &quot;zce&quot;,  age: 20,&#125;;const personProxy = new Proxy(person, &#123;  get(target, property, o) &#123;    return property in target ? target[property] : undefined;  &#125;,  set(target, pro, value, o) &#123;    //可以做一些内部校验    target[pro] = value;  &#125;,&#125;);console.log((personProxy.name = &quot;lagou&quot;));person; //&#123;name:&quot;lagou&quot;,age:20&#125;\n\n\n\nReflect概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。\n\n将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法\n\n修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false\n1234567891011121314// 老写法try &#123;  Object.defineProperty(target, property, attributes);  // success&#125; catch (e) &#123;  // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123;  // success&#125; else &#123;  // failure&#125;\n\n让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n12345// 老写法&quot;assign&quot; in Object; // true// 新写法Reflect.has(Object, &quot;assign&quot;); // true\n\n\n\n静态方法\nReflect.get\n\nReflect.get(target, name, receiver),Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined\n1234567891011var myObject = &#123;  foo: 1,  bar: 2,  get baz() &#123;    return this.foo + this.bar;  &#125;,&#125;;Reflect.get(myObject, &quot;foo&quot;); // 1Reflect.get(myObject, &quot;bar&quot;); // 2Reflect.get(myObject, &quot;baz&quot;); // 3\n\n如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。\n1234567891011121314var myObject = &#123;  foo: 1,  bar: 2,  get baz() &#123;    return this.foo + this.bar;  &#125;,&#125;;var myReceiverObject = &#123;  foo: 4,  bar: 4,&#125;;Reflect.get(myObject, &quot;baz&quot;, myReceiverObject); // 8\n\n如果第一个参数不是对象，Reflect.get方法会报错。\n12Reflect.get(1, &quot;foo&quot;); // 报错Reflect.get(false, &quot;foo&quot;); // 报错\n\n\n\nReflect.set\n\nReflect.set(target, name, value, receiver),Reflect.set方法设置target对象的name属性等于value\n12345678var myObject = &#123;  foo: 1,&#125;;myObject.foo; // 1Reflect.set(myObject, &quot;foo&quot;, 2);myObject.foo; // 2\n\n如果name属性设置了赋值函数，则赋值函数的this绑定receiver。\n1234567891011121314var myObject = &#123;  foo: 4,  set bar(value) &#123;    return (this.foo = value);  &#125;,&#125;;var myReceiverObject = &#123;  foo: 0,&#125;;Reflect.set(myObject, &quot;bar&quot;, 1, myReceiverObject);myObject.foo; // 4myReceiverObject.foo; // 1\n\n\n\nReflect.has\n\nReflect.has(obj, name),Reflect.has方法对应name in obj里面的in运算符\n123456789var myObject = &#123;  foo: 1,&#125;;// 旧写法&quot;foo&quot; in myObject; // true// 新写法Reflect.has(myObject, &quot;foo&quot;); // true\n\n如果Reflect.has()方法的第一个参数不是对象，会报错。\n\n\n\nReflect.deleteProperty\n\nReflect.deleteProperty(obj, name),Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性\n1234567const myObj = &#123; foo: &quot;bar&quot; &#125;;// 旧写法delete myObj.foo;// 新写法Reflect.deleteProperty(myObj, &quot;foo&quot;);\n\n该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。如果Reflect.deleteProperty()方法的第一个参数不是对象，会报错.\n\n\n\n\nPromise概述Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\npromise 特点Promise对象有以下两个特点。\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\npromise 使用方法\nES6 规定，Promise对象是一个构造函数，用来生成Promise实例。\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n1234567var p = new Promise(function (resolve, reject) &#123;  if (true) &#123;    resolve(data);  &#125; else &#123;    reject(data);  &#125;&#125;);\n\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n12345678p.then(  function (value) &#123;    // success业务处理  &#125;,  function (error) &#123;    // failure  &#125;);\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。\n\n看一个简单的例子\n12345678function time(ms) &#123;  return new Promise((resolve, reject) =&gt; &#123;    setTimeout(resolve, ms);  &#125;);&#125;time(1000).then((value) =&gt; &#123;  console.log(value);&#125;);\n\n\n\n\n\nPromise 新建后就会立即执行。\n12345678910111213let promise = new Promise(function (resolve, reject) &#123;  console.log(&quot;Promise&quot;);  resolve();&#125;);promise.then(function () &#123;  console.log(&quot;resolved.&quot;);&#125;);console.log(&quot;Hi!&quot;);//Promise//Hi//resolved\n\n\n\nclass概述ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。\n12345678910class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  toString() &#123;    return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;  &#125;&#125;\n\n基本介绍\nconstructor()\n\nconstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\n\n\n类的实例\n\n生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。\n1234567class Point &#123;  // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3);\n\n与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。\n12345678910111213141516171819class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  toString() &#123;    return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;  &#125;&#125;var point = new Point(2, 3);point.toString(); // (2, 3)point.hasOwnProperty(&quot;x&quot;); // truepoint.hasOwnProperty(&quot;y&quot;); // truepoint.hasOwnProperty(&quot;toString&quot;); // falsepoint.__proto__.hasOwnProperty(&quot;toString&quot;); // true\n\n与 ES5 一样，类的所有实例共享一个原型对象\n12345var p1 = new Point(2, 3);var p2 = new Point(3, 2);p1.__proto__ === p2.__proto__;//true\n\n\n\n\n\ngetter 和 setter\n\n与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n12345678910111213141516171819class MyClass &#123;  constructor() &#123;    // ...  &#125;  get prop() &#123;    return &quot;getter&quot;;  &#125;  set prop(value) &#123;    console.log(&quot;setter: &quot; + value);  &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop;// &#x27;getter&#x27;\n\n\n\n属性表达式\n\n类的属性名，可以采用表达式\n1234567891011let methodName = &quot;getArea&quot;;class Square &#123;  constructor(length) &#123;    // ...  &#125;  [methodName]() &#123;    // ...  &#125;&#125;\n\n上面代码中，Square类的方法名getArea，是从表达式得到的\n\n\n\n\nstatic\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”\n1234567891011class Foo &#123;  static classMethod() &#123;    return &quot;hello&quot;;  &#125;&#125;Foo.classMethod(); // &#x27;hello&#x27;var foo = new Foo();foo.classMethod();// TypeError: foo.classMethod is not a function\n\n解说：上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n注意，如果静态方法包含this关键字，这个this指的是类，而不是实例\n12345678910111213class Foo &#123;  static bar() &#123;    this.baz();  &#125;  static baz() &#123;    console.log(&quot;hello&quot;);  &#125;  baz() &#123;    console.log(&quot;world&quot;);  &#125;&#125;Foo.bar(); // hello\n\n解说：上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n父类的静态方法，可以被子类继承\n123456789class Foo &#123;  static classMethod() &#123;    return &quot;hello&quot;;  &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // &#x27;hello&#x27;\n\n静态属性\n静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性\nES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。\n1234567class MyClass &#123;  static myStaticProp = 42;  constructor() &#123;    console.log(MyClass.myStaticProp); // 42  &#125;&#125;\n\n\n\n继承\n简介\n\nClass 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n123class Point &#123;&#125;class ColorPoint extends Point &#123;&#125;\n\n解说：上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类\n\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。\n123456789class Point &#123;  /* ... */&#125;class ColorPoint extends Point &#123;  constructor() &#123;&#125;&#125;let cp = new ColorPoint(); // ReferenceError\n\n在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。\n1234567891011121314class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;&#125;class ColorPoint extends Point &#123;  constructor(x, y, color) &#123;    this.color = color; // ReferenceError    super(x, y);    this.color = color; // 正确  &#125;&#125;\n\n\n\nsuper\n\nsuper这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同\n\n第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。\n1234567class A &#123;&#125;class B extends A &#123;  constructor() &#123;    super();  &#125;&#125;\n\n解说：上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)`\n\n第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类\n1234567891011121314class A &#123;  p() &#123;    return 2;  &#125;&#125;class B extends A &#123;  constructor() &#123;    super();    console.log(super.p()); // 2  &#125;&#125;let b = new B();\n\n由于super指向父类的原型对象(prototype)，所以定义在父类实例上的方法或属性，是无法通过super调用的\n1234567891011121314class A &#123;  constructor() &#123;    this.p = 2;  &#125;&#125;class B extends A &#123;  get m() &#123;    return super.p;  &#125;&#125;let b = new B();b.m; // undefined\n\n\n\n\n\n\n\nSet基本用法\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet本身是一个构造函数，用来生成 Set 数据结构。\n\nSet函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n12const set = new Set([1, 2, 3, 4, 4]);console.log(set); //[1,2,3,4]\n\n\n数组去重\n1[...new Set([1, 2, 3, 2, 4, 5])]; //[1,2,3,4,5]\n\n字符串去重\n1[...new Set(&quot;ababbc&quot;)].join(&quot;&quot;); //&quot;abc&quot;\n\n\n\n\n\n属性和方法\nSet 结构的实例有以下属性。\n\nSet.prototype.constructor：构造函数，默认就是Set函数。\nSet.prototype.size：返回Set实例的成员总数。\n\n\nSet 实例的方法分为两大类\n\n操作方法（用于操作数据）\n\nSet.prototype.add(value)：添加某个值，返回 Set 结构本身\n123const items = new Set([]);items.add(1).add(2).add(3);console.dir(items); //[1,2,3]\n\nSet.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功\n1234const items = new Set([12, 23, 34]);var b = items.delete(12);console.log(b); //trueconsole.log(items); //Set(2) &#123;23, 34&#125;\n\nSet.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。\n\nSet.prototype.clear()：清除所有成员，没有返回值\n1234const items = new Set([12, 23, 34]);var b = items.clear(12);console.log(b); //undefinedconsole.log(items); //Set(0) &#123;&#125;\n\n\n\n遍历方法（用于遍历成员）\n\nSet.prototype.keys()：返回键名的遍历器\n\nSet.prototype.values()：返回键值的遍历器\n\nSet.prototype.entries()\n12345678910111213141516171819let set = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);for (let item of set.keys()) &#123;  console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123;  console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123;  console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]\n\nSet.prototype.forEach()\n12345let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &quot; : &quot; + value));// 1 : 1// 4 : 4// 9 : 9\n\n\n\n\n\n\n\nMap概述JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n基本用法\n作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组\n12345678910const map = new Map([  [&quot;name&quot;, &quot;张三&quot;],  [&quot;title&quot;, &quot;Author&quot;],]);map.size; // 2map.has(&quot;name&quot;); // truemap.get(&quot;name&quot;); // &quot;张三&quot;map.has(&quot;title&quot;); // truemap.get(&quot;title&quot;); // &quot;Author&quot;\n\n\n\n属性和方法\nsize 属性，size属性返回 Map 结构的成员总数。\n12345const map = new Map();map.set(&quot;foo&quot;, true);map.set(&quot;bar&quot;, false);map.size; // 2\n\nMap.prototype.set(key, value) set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键， set()方法返回的是 set 对象可以采用链式写法\n12345const m = new Map();m.set(&quot;edition&quot;, 6); // 键是字符串m.set(262, &quot;standard&quot;); // 键是数值m.set(undefined, &quot;nah&quot;); // 键是 undefined\n\nMap.prototype.get(key) get方法读取key对应的键值，如果找不到key，返回undefined。\n12345678const m = new Map();const hello = function () &#123;  console.log(&quot;hello&quot;);&#125;;m.set(hello, &quot;Hello ES6!&quot;); // 键是函数m.get(hello); // Hello ES6!\n\nMap.prototype.has(key)has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n12345678910const m = new Map();m.set(&quot;edition&quot;, 6);m.set(262, &quot;standard&quot;);m.set(undefined, &quot;nah&quot;);m.has(&quot;edition&quot;); // truem.has(&quot;years&quot;); // falsem.has(262); // truem.has(undefined); // true\n\n\n\nMap.prototype.delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。\n123456const m = new Map();m.set(undefined, &quot;nah&quot;);m.has(undefined); // truem.delete(undefined);m.has(undefined); // false\n\nMap.prototype.clear()clear方法清除所有成员，没有返回值\n1234567let map = new Map();map.set(&quot;foo&quot;, true);map.set(&quot;bar&quot;, false);map.size; // 2map.clear();map.size; // 0\n\n\n\n遍历\nMap.prototype.keys()：返回键名的遍历器。\n\nMap.prototype.values()：返回键值的遍历器\n\nMap.prototype.entries()：返回所有成员的遍历器\n\nMap.prototype.forEach()：遍历 Map 的所有成员\n1234567891011121314151617181920212223242526272829303132const map = new Map([  [&quot;F&quot;, &quot;no&quot;],  [&quot;T&quot;, &quot;yes&quot;],]);for (let key of map.keys()) &#123;  console.log(key);&#125;// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) &#123;  console.log(value);&#125;// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) &#123;  console.log(item[0], item[1]);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) &#123;  console.log(key, value);&#125;// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;map.forEach(function (value, key, map) &#123;  console.log(&quot;Key: %s, Value: %s&quot;, key, value);&#125;);\n\nforEach方法还可以接受第二个参数，用来绑定this。\n\n\nSymbol概述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n123456var obj = &#123;  say: &quot;lagou&quot;,&#125;;var say = Symbol(); //say 是symbol类型obj[say] = &quot;web&quot;;console.log(obj); //&#123;say: &quot;lagou&quot;, Symbol(): &quot;web&quot;&#125;\n\n语法\nSymbol函数前不能使用new命令，否则会报错\n\nSymbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分\n\n每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性\n123456var a = Symbol();var b = Symbol();console.log(a === b); //falsevar a = Symbol(&quot;a&quot;);var b = Symbol(&quot;b&quot;);console.log(a === b); //false\n\n注意：Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的\n123var a = Symbol(&quot;a&quot;);var b = Symbol(&quot;a&quot;);console.log(a === b); //false\n\nSymbol 值不能与其他类型的值进行运算，会报错\n123456let sym = Symbol(&quot;My symbol&quot;);&quot;your symbol is &quot; +  sym // TypeError: can&#x27;t convert symbol to string  `your symbol is $&#123;sym&#125;`;// TypeError: can&#x27;t convert symbol to string\n\nSymbol 值作为对象属性名时，不能用点运算符\n12345const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = &quot;Hello!&quot;;console.log(a[mySymbol]); //undefinedconsole.log(a[&quot;mySymbol&quot;]); //hello\n\n\n\nSymbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\n1234567const obj = &#123;&#125;;let a = Symbol(&quot;a&quot;);let b = Symbol(&quot;b&quot;);obj[a] = &quot;Hello&quot;;obj[b] = &quot;World&quot;;const objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols); //[Symbol(a), Symbol(b)]\n\n有时，我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\n1234let s1 = Symbol.for(&quot;foo&quot;);let s2 = Symbol.for(&quot;foo&quot;);s1 === s2; // true\n\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30 次，会返回 30 个不同的 Symbol 值\n1234Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;);// trueSymbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;);\n\n由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行\n1234567function foo() &#123;  return Symbol.for(&quot;bar&quot;);&#125;const x = foo();const y = Symbol.for(&quot;bar&quot;);console.log(x === y); // true\n\n\n\n可迭代接口Iterater 的概念\n简单介绍\nJavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\nIterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。\n\nIterator 的遍历过程\n\n创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员\n\n第二次调用指针对象的next方法，指针就指向数据结构的第二个成员\n\n不断调用指针对象的next方法，直到它指向数据结构的结束位置\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n1234567891011121314151617简单的Iterator遍历器的实现;var it = easyIterator([&quot;a&quot;, &quot;b&quot;]);it.next(); // &#123; value: &quot;a&quot;, done: false &#125;it.next(); // &#123; value: &quot;b&quot;, done: false &#125;it.next(); // &#123; value: undefined, done: true &#125;function easyIterator(array) &#123;  var nextIndex = 0;  return &#123;    next: function () &#123;      return nextIndex &lt; array.length        ? &#123; value: array[nextIndex++], done: false &#125;        : &#123; value: undefined, done: true &#125;;    &#125;,  &#125;;&#125;\n\n\n\n\n\nIterater 接口\n字符串 数组 set map arguments 都有 iterater 接口，nodelist 集合，都可以用 for of 遍历\n1234567891011121314var st = &quot;lagou&quot;;for (i of st) &#123;  console.log(i); // l a g o u&#125;var arr = [1, 2];for (v of arr) &#123;  console.log(v); //1 2&#125;function fn(a, b, c) &#123;  for (i of arguments) &#123;    console.log(i); //1 2 3  &#125;&#125;fn(1, 2, 3);\n\n\n\nModules概述\nJavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n\n语法\nexport\n\nexport命令用于规定模块的对外接口\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量\n12345678910//demo.jsexport var firstName = &quot;Michael&quot;;export var lastName = &quot;Jackson&quot;;export var year = 1958;//或者var firstName = &quot;Michael&quot;;var lastName = &quot;Jackson&quot;;var year = 1958;export &#123; firstName, lastName, year &#125;;\n\n\n\nimport\n\nimport命令用于输入其他模块提供的功能\n\nimport命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同\n123456// main.jsimport &#123; firstName, lastName, year &#125; from &quot;./profile.js&quot;;function setName(element) &#123;  element.textContent = firstName + &quot; &quot; + lastName;&#125;\n\n\n\n-\n\nexport default\n\n为了给用户提供方便，就要用到export default命令，为模块指定默认输出\n\n本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字\n\n在import命令后面，不再使用大括号\n\nexport default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次\n1234// export-default.jsexport default function () &#123;  console.log(&quot;foo&quot;);&#125;\n\n123// import-default.jsimport customName from &quot;./export-default&quot;;customName(); // &#x27;foo&#x27;\n\n\n\n\n\n浏览器端加载实现\n浏览器加载 ES6 模块，也使用标签，但是要加入type=&quot;module&quot;属性\n12// 01.jsexport var a = 123;\n\n12//demo.html&lt;script type=&quot;module&quot;&gt;import &#123;a&#125; from &quot;./01.js&quot;; console.log(a)//123&lt;/script&gt;\n\n\n\n脚本异步加载\n12&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;\n\n解说：上面代码中，标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。\n\n","dateCreated":"2020-09-14T09:47:13+08:00","dateModified":"2020-09-19T16:38:58+08:00","datePublished":"2020-09-14T09:47:13+08:00","description":"ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。","headline":"es6整理","image":["https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg","cover-v1.2.0.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/09/14/es6%E6%95%B4%E7%90%86/"},"publisher":{"@type":"Organization","name":"Liper","sameAs":["https://github.com/","mailto"],"image":"cover.jpg","logo":{"@type":"ImageObject","url":"cover.jpg"}},"url":"http://yoursite.com/2020/09/14/es6%E6%95%B4%E7%90%86/","keywords":"js","thumbnailUrl":"https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg"}</script>
    <meta name="description" content="ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。">
<meta property="og:type" content="blog">
<meta property="og:title" content="es6整理">
<meta property="og:url" content="http://yoursite.com/2020/09/14/es6%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="LIPER">
<meta property="og:description" content="ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-14T01:47:13.000Z">
<meta property="article:modified_time" content="2020-09-19T08:38:58.125Z">
<meta property="article:author" content="Liper">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/cover.jpg"/>
    
    
        <meta property="og:image" content="https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg"/>
    
    
        <meta property="og:image" content="http://yoursite.com/2020/09/14/es6%E6%95%B4%E7%90%86/cover-v1.2.0.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://yoursite.com/2020/09/14/es6%E6%95%B4%E7%90%86/cover-v1.2.0.jpg"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-xrypzi5utvjdggbat5gkdwxqbgttnkrvs7tlchsgv99hft5dd4siavxjhxz5.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            LIPER
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/cover.jpg" alt="cover.jpg"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/cover.jpg" alt="cover.jpg"/>
                </a>
                <h4 class="sidebar-profile-name">Liper</h4>
                
                    <h5 class="sidebar-profile-bio"><p>I write code to enrich and ease life of others.</p></h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--partial"
             style="background-image:url('/2020/09/14/es6%E6%95%B4%E7%90%86/cover-v1.2.0.jpg');"
             data-behavior="4">
            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaOut
                        hasCoverCaption">
                
<article class="post">
    
        <span class="post-header-cover-caption caption">A beautiful sunrise</span>
    
    
        <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            es6整理
        </h1>
    
    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!--excerpt-->
<p><strong>ECMAScript2015</strong></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><h4 id="1-新的标准规范"><a href="#1-新的标准规范" class="headerlink" title="1.新的标准规范"></a>1.新的标准规范</h4><p>ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。</p>
<h4 id="2-ECMAScript-和-js-关系"><a href="#2-ECMAScript-和-js-关系" class="headerlink" title="2.ECMAScript 和 js 关系"></a>2.ECMAScript 和 js 关系</h4><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。javascript 是 netscape 创 造的并交给了国际标准化组织 ECMA，之所以不叫做 JavaScript 由于商标的问题，java 是 sun 公司的商标，根据 授权协议只有 Netscape 公司可以合法使用 JavaScript 这个名字，另外就是为了体现 JavaScript 的标准的制定者 不是 ECMA 所以取名为 ECMAScript。</p>
<h4 id="3-ES6-与-ECMAScript-2015-的关系"><a href="#3-ES6-与-ECMAScript-2015-的关系" class="headerlink" title="3.ES6 与 ECMAScript 2015 的关系"></a>3.ES6 与 ECMAScript 2015 的关系</h4><p>ES6 是 ECMA 的为 JavaScript 制定的第 6 个版本的标准，标准委员会最终决定，标准在每年的 6 月份正式发布一 次，作为当年的正式版本。ECMAscript 2015 是在 2015 年 6 月份发布的 ES6 的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本……</p>
<h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><h4 id="1-块级作用域的种类"><a href="#1-块级作用域的种类" class="headerlink" title="1.块级作用域的种类"></a>1.块级作用域的种类</h4><p>ECMAScript2015 为 js 提出的第三个作用域，凡是带{}的都是一个块级作用域。</p>
<p>if 语句的{},for 循环中的{},while 中的{},或者是我们单独写的{} try{}catch(error){}这些都提供了块级作用域。</p>
<h4 id="块级作用域分析"><a href="#块级作用域分析" class="headerlink" title="块级作用域分析"></a>块级作用域分析</h4><h5 id="1-为什么需要块级作用域？"><a href="#1-为什么需要块级作用域？" class="headerlink" title="1.为什么需要块级作用域？"></a>1.为什么需要块级作用域？</h5><ul>
<li><p>内层变量会覆盖外层变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lagou = <span class="string">&quot;拉勾&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(lagou); <span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lagou = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这是因为 fn 函数体内以及有 var 声明的变量 lagou，只是还没有赋值，默认为 undefined。</p>
<ul>
<li><p>用来计数的循环变量泄露为全局变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-块级作用域的成员"><a href="#2-块级作用域的成员" class="headerlink" title="2.块级作用域的成员"></a>2.块级作用域的成员</h5><p>块级作用域内的成员需要使用 let 或 const 命令定义的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lagou = <span class="string">&quot;拉勾&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(lagou); <span class="comment">//拉勾</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> lagou = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<h1 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h1><h4 id="1-let"><a href="#1-let" class="headerlink" title="1.let"></a>1.let</h4><p>基本用法</p>
<p>ECMAScript2015 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<p>let 主要声明块级作用域下的成员，这个成员变量的作用域范围只能在当前块级作用域下。</p>
<ul>
<li>wer</li>
<li>er</li>
</ul>
<h4 id="2-const"><a href="#2-const" class="headerlink" title="2.const"></a>2.const</h4><p>const 声明变量的同时必须要赋值。</p>
<p>const 声明之后，不允许去修改它的值，这里面的值说的是不允许修改它，是声明之后不允许重新指向一个新</p>
<p>的内存地址，可以去修改内存地址中的属性成员。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h4 id="1-数组的解构"><a href="#1-数组的解构" class="headerlink" title="1.数组的解构"></a>1.数组的解构</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>
<ul>
<li><p>完全解构 将数组中的每一个值都对应上相应的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;lagou&quot;</span>, <span class="string">&quot;edu&quot;</span>, <span class="string">&quot;web&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [com, ind, work] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(work); <span class="comment">//web</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不完全解构 数组中的部分值对应上了相应的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;lagou&quot;</span>, <span class="string">&quot;edu&quot;</span>, <span class="string">&quot;web&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [, , work] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(work); <span class="comment">//web</span></span><br></pre></td></tr></table></figure>

<p>注意:模式没有匹配上的可以不填，但是必须要加逗号隔开。</p>
</li>
</ul>
<ul>
<li><p>扩展运算符…</p>
<ul>
<li><p>展开运算符说明</p>
<ul>
<li><p>三个点(…)是一个展开运算符，其功能为对三个点后面的变量进行展开操作</p>
</li>
<li><p>三个点(…)展开运算符:只能对具有 Iterator 接口的对象进行展开操作</p>
</li>
<li><p>使用场景</p>
<pre><code>![image-20200508180111209](imgs/image-20200508180111209.png)

案例一

&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[&lt;span class=&quot;string&quot;&gt;&amp;quot;拉勾&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;edu&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn(...arr)&lt;span class=&quot;comment&quot;&gt;//web&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例二`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = [&lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;102&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;103&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.push(...b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;//[88, 99, 100, 101, 102, 103]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例三`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; d=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e:&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f:&lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g:&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;h:&lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;h&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;e&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;f&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例四`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; st=&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩 edu&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[...st];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)&lt;span class=&quot;comment&quot;&gt;//[&amp;quot;拉&amp;quot;, &amp;quot;钩&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;u&amp;quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`掌握了展开运算符的使用规则，我们看一下数组的特殊解构。`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [a,...b] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a)&lt;span class=&quot;comment&quot;&gt;//1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b)&lt;span class=&quot;comment&quot;&gt;//[2,3,4,5,6]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 解构不成功</span><br><span class="line"></span><br><span class="line">  右边的变量的个数超过了等号左边中数组的元素</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;js</span><br><span class="line">  let [a, b, c] &#x3D; [12];</span><br><span class="line">  console.log(b); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>如果解构没有成功，则变量的值是 undefined，如果是展开运算的变量则是空数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, ...c] = [<span class="number">12</span>];</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-数组的扩展"><a href="#2-数组的扩展" class="headerlink" title="2.数组的扩展"></a>2.数组的扩展</h4><ul>
<li><p>扩展运算符…</p>
<ul>
<li><p>扩展运算符（spread）是三个点（<code>...</code>）它好比<a href="#rest"> rest 参数的逆运算</a>，将一个数组转为用逗号分隔的参数序列。</p>
</li>
<li><p>替代 apply()的使用技巧</p>
<p>我们之前在求一个数组中的最大值得时候采用得方式是 Math.max.apply(null,[12,34,56,43]) ==56</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">43</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(max); <span class="comment">//56</span></span><br><span class="line"><span class="keyword">var</span> max2 = <span class="built_in">Math</span>.max(...[<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">43</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(max2); <span class="comment">//56</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Array 类的扩展方法</p>
<ul>
<li>Array.from()</li>
</ul>
<p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arraylike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;lagou&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;edu&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;web&quot;</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(arraylike);</span><br><span class="line">[<span class="string">&quot;lagou&quot;</span>, <span class="string">&quot;edu&quot;</span>, <span class="string">&quot;web&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>Array.from 还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[1,4,9]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Array.of 方法用于将一组值，转换为数组，这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">//[emptyx3]</span></span><br></pre></td></tr></table></figure>

<p>这里面 3 表示数组中元素的长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">//[2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>当<code>Array()</code>里的参数个数大于 1 的时候，表示的是数组元素。</p>
<p><code>Array.of()</code>方法不管里面参数的个数多少，都将其转为数组的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[3]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h4 id="1-对象中有关变量的解构赋值"><a href="#1-对象中有关变量的解构赋值" class="headerlink" title="1.对象中有关变量的解构赋值"></a>1.对象中有关变量的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; name, work &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;lagou&quot;</span>, <span class="attr">work</span>: <span class="string">&quot;web&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(name, work); <span class="comment">//lagou web</span></span><br></pre></td></tr></table></figure>

<h4 id="2-对象的扩展"><a href="#2-对象的扩展" class="headerlink" title="2.对象的扩展"></a>2.对象的扩展</h4><ul>
<li><p>对象的简写</p>
<ul>
<li><p>当变量名和属性名同名式，省略同名的属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; foo &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123; <span class="attr">foo</span>: foo &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>省略方法中的 function</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;拉勾!&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;拉勾!&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>属性的赋值器（setter）和取值器（getter）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lagou = &#123;</span><br><span class="line">  name: <span class="string">&quot;拉勾&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">com</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">work</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="built_in">this</span>.name + value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(lagou.com); <span class="comment">//拉勾</span></span><br><span class="line">lagou.work = <span class="string">&quot;招聘&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lagou.name); <span class="comment">//拉勾招聘</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属性名表达式</p>
<p>es5 中定义对象的属性有两种方法，一种是用标识符做属性，一种是用表达式做属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法一;</span><br><span class="line">obj.name = <span class="string">&quot;拉勾&quot;</span>;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;拉勾&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lagou = &#123;</span><br><span class="line">  name: <span class="string">&quot;拉勾&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果使用大括号定义对象，那么在 es5 中只能使用标识符定义属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lagou = &#123;</span><br><span class="line">  name: <span class="string">&quot;拉勾&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是 ECMAScript2015 在使用大括号定义对象的时候，允许使用表达式定义属性，把表达式放在方括号中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;lagou&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> lagou = &#123;</span><br><span class="line">  [name]: <span class="string">&quot;web&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(lagou); <span class="comment">//&#123;lagou: &quot;web&quot;&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="3-三点运算在对象中的用途"><a href="#3-三点运算在对象中的用途" class="headerlink" title="3.三点运算在对象中的用途"></a>3.三点运算在对象中的用途</h4><ul>
<li><p>用于对象的解构</p>
<ul>
<li><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(z); <span class="comment">//&#123;a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>
<pre><code>注意:1.解构赋值必须是最后一个参数。2.解构赋值的拷贝是浅拷贝。</code></pre>
</li>
</ul>
</li>
<li><p>用于扩展运算</p>
<ul>
<li><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">name</span>: <span class="string">&quot;lagou&quot;</span>, <span class="attr">work</span>: <span class="string">&quot;web&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n; <span class="comment">// &#123; name: &quot;lagou&quot;, work: &quot;web&quot; &#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h4 id="1-字符串模板"><a href="#1-字符串模板" class="headerlink" title="1.字符串模板"></a>1.字符串模板</h4><ul>
<li><p>传统的字符串里不能使用换行符，必须使用转义符\n 替代，字符串模板里可以使用。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
</li>
<li><p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;拉勾&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> st = <span class="string">`欢迎来到<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(st);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-标签模板"><a href="#2-标签模板" class="headerlink" title="2.标签模板"></a>2.标签模板</h4><ul>
<li><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log<span class="string">`hello`</span>;</span><br><span class="line">等同于;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>注意:如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;laogou&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> work=<span class="string">&quot;web&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">st,a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(st);</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello lagou&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st=tag<span class="string">`hello<span class="subst">$&#123;name&#125;</span>,职业<span class="subst">$&#123;work&#125;</span>开发`</span></span><br><span class="line"><span class="built_in">console</span>.log(st)<span class="comment">//hello lagou</span></span><br><span class="line">[<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;,职业&quot;</span>, <span class="string">&quot;开发&quot;</span>, <span class="attr">raw</span>: <span class="built_in">Array</span>(<span class="number">3</span>)]</span><br><span class="line">laogou</span><br><span class="line">web</span><br></pre></td></tr></table></figure>

<p>函数内的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;laogou&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> work = <span class="string">&quot;web&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">st, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(st);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello lagou&quot;</span>; <span class="comment">//如果没有返回值，则默认是undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st = tag<span class="string">`hello<span class="subst">$&#123;name&#125;</span>,职业<span class="subst">$&#123;work&#125;</span>开发`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(st); <span class="comment">//hello lagou</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-扩展的方法"><a href="#3-扩展的方法" class="headerlink" title="3.扩展的方法"></a>3.扩展的方法</h4><ul>
<li><p>字符串实例的方法</p>
<ul>
<li><p><strong>includes()</strong></p>
<p>返回布尔值，表示是否找到了参数字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> st = <span class="string">&quot;lagou web&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = st.includes(<span class="string">&quot;web&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>startsWith()</strong></p>
<p>返回布尔值，表示参数字符串是否在原字符串的头部</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> st = <span class="string">&quot;lagou web&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = st.startsWith(<span class="string">&quot;la&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>endsWith()</strong></p>
<p>返回布尔值，表示参数字符串是否在原字符串的尾部</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> st = <span class="string">&quot;lagou web&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = st.endsWith(<span class="string">&quot;web&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><ul>
<li><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b = <span class="string">&quot; lagou &quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">&quot;hello&quot;</span>); <span class="comment">//hello lagou</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意:</p>
<ul>
<li>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明.</li>
<li>使用参数默认值时，函数不能有同名参数</li>
</ul>
</li>
<li><p>参数默认值的位置</p>
<ul>
<li><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a><span name="app">rest 参数</span></h4><ul>
<li><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>); <span class="comment">// [2, 5, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>rest 参数和函数中的参数解构有什么区别</p>
<ul>
<li>rest 参数是发生在函数的定义阶段，函数的额参数解构是发生在函数的调用阶段</li>
<li>二者是一种互为逆运算</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这是rest参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>); <span class="comment">// [2, 5, 3]</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line">fn(...arr); <span class="comment">//6  这是参数的解构</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul>
<li>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;; <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数有几个使用注意点<ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数外面的 this 是什么，箭头函数内的 this 还是什么。</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;web&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;lagou&quot;</span>,</span><br><span class="line">    fn()&#123;</span><br><span class="line">        <span class="keyword">var</span> t=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)<span class="comment">//web  this是window</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;web&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;lagou&quot;</span>,</span><br><span class="line">    fn()&#123;</span><br><span class="line">        <span class="keyword">var</span> t=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)<span class="comment">//lagou this是obj</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br></pre></td></tr></table></figure>

<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><ul>
<li><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: <span class="number">123</span>,</span><br><span class="line">  b: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sourcel = &#123;</span><br><span class="line">  a: <span class="number">456</span>,</span><br><span class="line">  c: <span class="number">456</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Object</span>.assign(target, sourcel);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">//&#123;a: 456, b: 123, c: 456&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(target === result); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性。且<code>assign()</code>的返回值就是第一个对象。</p>
<p>如果有多个源对象有同名属性，依然是后面的会覆盖前面的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<code>Object.assign()</code>复制一个对象，且其中一个对象的修改不会影响到另一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourcel = &#123;</span><br><span class="line">  a: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, sourcel);</span><br><span class="line">obj.a = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a: 456&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(sourcel); <span class="comment">//&#123;a: 123&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><ul>
<li><p><code>Object.is</code>就是用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Proxy 可以理解成一个快递员，我们发快递还是接受快递，都需要这个快递员充当一个代理的作用。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，这个实例就是一个代理对象（快递员）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<h4 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h4><p>这个代理对象有两个参数，一个是代理的目标对象，第二个也是一个对象，它是配置对象，用来定制代理的拦截行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;zce&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, property); <span class="comment">//person&#123;name:&quot;zce&quot;,age:20&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set() &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h4><ul>
<li><p>配置对象中一般有两个方法<code>get</code>和<code>set</code>,<code>get</code>是用来拦截对目标对象属性的访问请求。<code>get</code>方法中有两个参数，第一个参数是目标对象，第二个参数是访问的那个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;zce&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  get(target, property) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, property);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set() &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personProxy.name); <span class="comment">//100</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意，这个<code>get</code>方法的返回值就是我们获取的这个属性的返回值。</p>
<ul>
<li><p>这个<code>get</code>方法中有三个参数，一个是代理的目标对象，一个是代理的处理对象，第三个参数是 proxy 实例本身，且第三个参数是可选参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;zce&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  get(target, property, o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">//proxy&#123;name:&quot;zec&quot;,age:20&#125;</span></span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set() &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(personProxy.age); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个<code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;zce&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  get(target, property, o) &#123;</span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(obj, pro, value, o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj, pro, value, o);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((personProxy.name = <span class="string">&quot;zhang&quot;</span>));</span><br><span class="line"><span class="comment">//&#123;name: &quot;zce&quot;, age: 20&#125; &quot;name&quot; &quot;zhang&quot; Proxy &#123;name: &quot;zce&quot;, age: 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以去设置一些属性或修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;zce&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  get(target, property, o) &#123;</span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, pro, value, o) &#123;</span><br><span class="line">    <span class="comment">//可以做一些内部校验</span></span><br><span class="line">    target[pro] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log((personProxy.name = <span class="string">&quot;lagou&quot;</span>));</span><br><span class="line">person; <span class="comment">//&#123;name:&quot;lagou&quot;,age:20&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>
<ul>
<li><p>将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</p>
</li>
<li><p>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">&quot;assign&quot;</span> <span class="keyword">in</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">&quot;assign&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul>
<li><p>Reflect.get</p>
<ul>
<li><p><code>Reflect.get(target, name, receiver)</code>,<code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.foo + <span class="built_in">this</span>.bar;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">&quot;foo&quot;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">&quot;bar&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">&quot;baz&quot;</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.foo + <span class="built_in">this</span>.bar;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  foo: <span class="number">4</span>,</span><br><span class="line">  bar: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.get(myObject, <span class="string">&quot;baz&quot;</span>, myReceiverObject); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.get(<span class="number">1</span>, <span class="string">&quot;foo&quot;</span>); <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(<span class="literal">false</span>, <span class="string">&quot;foo&quot;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Reflect.set</p>
<ul>
<li><p><code>Reflect.set(target, name, value, receiver)</code>,<code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.foo; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">&quot;foo&quot;</span>, <span class="number">2</span>);</span><br><span class="line">myObject.foo; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">4</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.foo = value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  foo: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.set(myObject, <span class="string">&quot;bar&quot;</span>, <span class="number">1</span>, myReceiverObject);</span><br><span class="line">myObject.foo; <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.foo; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Reflect.has</p>
<ul>
<li><p><code>Reflect.has(obj, name)</code>,<code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="string">&quot;foo&quot;</span> <span class="keyword">in</span> myObject; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(myObject, <span class="string">&quot;foo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p>
</li>
</ul>
</li>
<li><p>Reflect.deleteProperty</p>
<ul>
<li><p>Reflect.deleteProperty(obj, name),<code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">delete</span> myObj.foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(myObj, <span class="string">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错.</p>
</li>
</ul>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<h4 id="promise-特点"><a href="#promise-特点" class="headerlink" title="promise 特点"></a>promise 特点</h4><p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<h4 id="promise-使用方法"><a href="#promise-使用方法" class="headerlink" title="promise 使用方法"></a>promise 使用方法</h4><ul>
<li><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
</li>
<li><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    resolve(data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
</li>
<li><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success业务处理</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>
<ul>
<li><p>看一个简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">time(<span class="number">1000</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Promise 新建后就会立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;resolved.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line"><span class="comment">//Promise</span></span><br><span class="line"><span class="comment">//Hi</span></span><br><span class="line"><span class="comment">//resolved</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>.x + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li><p><code>constructor()</code></p>
<ul>
<li><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</li>
</ul>
</li>
<li><p>类的实例</p>
<ul>
<li><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> point = Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>.x + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">point.toString(); <span class="comment">// (2, 3)</span></span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">&quot;x&quot;</span>); <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&quot;y&quot;</span>); <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&quot;toString&quot;</span>); <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">&quot;toString&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与 ES5 一样，类的所有实例共享一个原型对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__;</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>getter 和 setter</p>
<ul>
<li><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;getter&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;setter: &quot;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop;</span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>属性表达式</p>
<ul>
<li><p>类的属性名，可以采用表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">&quot;getArea&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的</p>
</li>
</ul>
</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod();</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>解说：上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
</li>
<li><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> bar() &#123;</span><br><span class="line">    <span class="built_in">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar(); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>解说：上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>
</li>
<li><p>父类的静态方法，可以被子类继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod(); <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态属性</p>
<p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性</p>
<p>ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-class-fields">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>简介</p>
<ul>
<li><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>解说：上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类</p>
</li>
<li><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">super</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>super</p>
<ul>
<li><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同</p>
<ul>
<li><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解说：上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B的实例，因此</code>super()<code>在这里相当于</code>A.prototype.constructor.call(this)`</p>
</li>
<li><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于<code>super</code>指向父类的原型对象(prototype)，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
</li>
<li><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>
</li>
<li><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])]; <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&quot;ababbc&quot;</span>)].join(<span class="string">&quot;&quot;</span>); <span class="comment">//&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><ul>
<li><p>Set 结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
</li>
<li><p>Set 实例的方法分为两大类</p>
<ul>
<li><p>操作方法（用于操作数据）</p>
<ul>
<li><p><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([]);</span><br><span class="line">items.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(items); <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>]);</span><br><span class="line"><span class="keyword">var</span> b = items.delete(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(items); <span class="comment">//Set(2) &#123;23, 34&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</p>
</li>
<li><p><code>Set.prototype.clear()</code>：清除所有成员，没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>]);</span><br><span class="line"><span class="keyword">var</span> b = items.clear(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(items); <span class="comment">//Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>遍历方法（用于遍历成员）</p>
<ul>
<li><p><code>Set.prototype.keys()</code>：返回键名的遍历器</p>
</li>
<li><p><code>Set.prototype.values()</code>：返回键值的遍历器</p>
</li>
<li><p>Set.prototype.entries()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Set.prototype.forEach()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">&quot; : &quot;</span> + value));</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li><p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Author&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size; <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&quot;name&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&quot;name&quot;</span>); <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.has(<span class="string">&quot;title&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&quot;title&quot;</span>); <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h4><ul>
<li><p>size 属性，<code>size</code>属性返回 Map 结构的成员总数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&quot;bar&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map.prototype.set(key, value) <code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键， set()方法返回的是 set 对象可以采用链式写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&quot;edition&quot;</span>, <span class="number">6</span>); <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&quot;standard&quot;</span>); <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&quot;nah&quot;</span>); <span class="comment">// 键是 undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map.prototype.get(key) <code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">m.set(hello, <span class="string">&quot;Hello ES6!&quot;</span>); <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.get(hello); <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map.prototype.has(key)<code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&quot;edition&quot;</span>, <span class="number">6</span>);</span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&quot;standard&quot;</span>);</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&quot;nah&quot;</span>);</span><br><span class="line"></span><br><span class="line">m.has(<span class="string">&quot;edition&quot;</span>); <span class="comment">// true</span></span><br><span class="line">m.has(<span class="string">&quot;years&quot;</span>); <span class="comment">// false</span></span><br><span class="line">m.has(<span class="number">262</span>); <span class="comment">// true</span></span><br><span class="line">m.has(<span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Map.prototype.delete(key)<code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&quot;nah&quot;</span>);</span><br><span class="line">m.has(<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.delete(<span class="literal">undefined</span>);</span><br><span class="line">m.has(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map.prototype.clear()<code>clear</code>方法清除所有成员，没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&quot;bar&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size; <span class="comment">// 2</span></span><br><span class="line">map.clear();</span><br><span class="line">map.size; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul>
<li><p><code>Map.prototype.keys()</code>：返回键名的遍历器。</p>
</li>
<li><p><code>Map.prototype.values()</code>：返回键值的遍历器</p>
</li>
<li><p><code>Map.prototype.entries()</code>：返回所有成员的遍历器</p>
</li>
<li><p><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;F&quot;</span>, <span class="string">&quot;no&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;T&quot;</span>, <span class="string">&quot;yes&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>
</li>
</ul>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  say: <span class="string">&quot;lagou&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> say = <span class="built_in">Symbol</span>(); <span class="comment">//say 是symbol类型</span></span><br><span class="line">obj[say] = <span class="string">&quot;web&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;say: &quot;lagou&quot;, Symbol(): &quot;web&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li><p><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错</p>
</li>
<li><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</p>
</li>
<li><p>每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol 值不能与其他类型的值进行运算，会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">&quot;My symbol&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;your symbol is &quot;</span> +</span><br><span class="line">  sym <span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line">  <span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol 值作为对象属性名时，不能用点运算符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.mySymbol = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="string">&quot;mySymbol&quot;</span>]); <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">obj[a] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">obj[b] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols); <span class="comment">//[Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = foo();</span><br><span class="line"><span class="keyword">const</span> y = <span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="可迭代接口"><a href="#可迭代接口" class="headerlink" title="可迭代接口"></a>可迭代接口</h1><h4 id="Iterater-的概念"><a href="#Iterater-的概念" class="headerlink" title="Iterater 的概念"></a>Iterater 的概念</h4><ul>
<li><p>简单介绍</p>
<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>
</li>
<li><p>Iterator 的遍历过程</p>
<ul>
<li><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
</li>
<li><p>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</p>
</li>
<li><p>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</p>
</li>
<li><p>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</p>
<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">简单的Iterator遍历器的实现;</span><br><span class="line"><span class="keyword">var</span> it = easyIterator([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easyIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length</span><br><span class="line">        ? &#123; <span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        : &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="Iterater-接口"><a href="#Iterater-接口" class="headerlink" title="Iterater 接口"></a>Iterater 接口</h4><ul>
<li><p>字符串 数组 set map arguments 都有 iterater 接口，nodelist 集合，都可以用 for of 遍历</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> st = <span class="string">&quot;lagou&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">of</span> st) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// l a g o u</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">//1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">//1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><ul>
<li>JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
</ul>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul>
<li><p>export</p>
<ul>
<li><p><code>export</code>命令用于规定模块的对外接口</p>
</li>
<li><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&quot;Michael&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&quot;Jackson&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&quot;Michael&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&quot;Jackson&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>import</p>
<ul>
<li><p><code>import</code>命令用于输入其他模块提供的功能</p>
</li>
<li><p><code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&quot;./profile.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>-</p>
</li>
<li><p>export default</p>
<ul>
<li><p>为了给用户提供方便，就要用到<code>export default</code>命令，为模块指定默认输出</p>
</li>
<li><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字</p>
</li>
<li><p>在<code>import</code>命令后面，不再使用大括号</p>
</li>
<li><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&quot;./export-default&quot;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="浏览器端加载实现"><a href="#浏览器端加载实现" class="headerlink" title="浏览器端加载实现"></a>浏览器端加载实现</h4><ul>
<li><p>浏览器加载 ES6 模块，也使用标签，但是要加入<code>type=&quot;module&quot;</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo.html</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;<span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&quot;./01.js&quot;</span>; <span class="built_in">console</span>.log(a)<span class="comment">//123&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>脚本异步加载</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>解说：上面代码中，标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。</p>
</li>
</ul>
            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/js/" rel="tag">js</a>

            </div>
        
        
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Liper. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/cover.jpg" alt="cover.jpg"/>
        
            <h4 id="about-card-name">Liper</h4>
        
            <div id="about-card-bio"><p>I write code to enrich and ease life of others.</p></div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>前端开发</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                浙江-杭州
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-xsbhvwgmrvs7y66t1asi0w8ljlicdyj3ltwbfxxzmdtzgdnpvch4jogtdj8b.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
